## Завдання

`Python` має дві вбудовані функції сортування: `sorted` і `sort`. Функції сортування `Python` використовують `Timsort` — гібридний алгоритм сортування, що поєднує в собі сортування злиттям і сортування вставками.

Порівняйте три алгоритми сортування: злиттям, вставками та Timsort за часом виконання. Аналіз повинен бути підтверджений емпіричними даними, отриманими шляхом тестування алгоритмів на різних наборах даних. Емпірично перевірте теоретичні оцінки складності алгоритмів, наприклад, сортуванням на великих масивах. Для заміру часу виконання алгоритмів використовуйте модуль timeit.

Покажіть, що поєднання сортування злиттям і сортування вставками робить алгоритм Timsort набагато ефективнішим, і саме з цієї причини програмісти, в більшості випадків, використовують вбудовані в Python алгоритми, а не кодують самі. Зробіть висновки.

_Необов'язкове завдання_

Дано `k` відсортованих списків цілих чисел. Ваше завдання — об'єднати їх у один відсортований список. При виконанні завдання можете опиратися на алгоритм сортування злиттям з конспекту. Реалізуйте функцію merge_k_lists , яка приймає на вхід список відсортованих списків та повертає відсортований список.

## Висновки

**Сортування вставками:**

- Найгірші результати спостерігаються для випадкових масивів великого розміру (10000 елементів). Це пов’язано з тим, що сортування вставками має квадратичну складність O(n²), що робить його дуже неефективним для великих масивів.
- Частково відсортовані масиви демонструють кращі результати, оскільки алгоритм вставок добре працює на майже відсортованих даних, і час сортування в таких випадках наближається до O(n).
- Відсортовані масиви показують найкращі результати, оскільки для вже відсортованих масивів алгоритм лише перевіряє кожен елемент, що займає лінійний час O(n). Проте навіть в цьому випадку сортування вставками є менш ефективним, ніж Timsort.

**Сортування злиттям:**

- Незалежно від типу масиву (випадковий, частково відсортований чи відсортований), сортування злиттям демонструє стабільну продуктивність. Це відповідає теоретичній оцінці O(n log n) для всіх випадків.
- Перевага цього алгоритму полягає в тому, що він працює з однаковою ефективністю на будь-якому наборі даних, включаючи випадкові та відсортовані масиви.
- Однак сортування злиттям вимагає додаткової пам'яті для злиття масивів, що робить його менш практичним в деяких випадках порівняно з Timsort.

**Timsort (вбудовані функції sorted і sort):**

- Найшвидший алгоритм для всіх типів масивів. Це зумовлено тим, що Timsort оптимізований для реальних даних і поєднує сортування вставками (для малих масивів) із сортуванням злиттям (для великих масивів). Він адаптивний і швидко працює на частково відсортованих масивах.
- Частково відсортовані масиви демонструють значне зростання швидкості, оскільки Timsort розпізнає відсортовані ділянки та ефективно їх обробляє.
- Для випадкових і вже відсортованих масивів Timsort також показує найкращі результати, перевершуючи інші алгоритми. Це пояснюється тим, що його складність становить O(n log n) у середньому, але завдяки оптимізації він працює швидше, ніж чисте сортування злиттям.

**Загальні висновки:**

- Timsort є найефективнішим алгоритмом для сортування на всіх типах даних завдяки адаптивності та поєднанню переваг сортування злиттям і вставками.
- Сортування вставками є прийнятним лише для малих і майже відсортованих масивів, але дуже неефективним для великих випадкових масивів.
- Сортування злиттям забезпечує стабільну продуктивність для всіх типів даних, проте не настільки швидке, як Timsort.
